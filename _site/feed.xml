<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-09-25T14:52:35+02:00</updated><id>http://localhost:4000/</id><title type="html">Divergences</title><subtitle>Working in different directions
</subtitle><author><name>Romain Girard</name></author><entry><title type="html">Multi-Scale DenseNet</title><link href="http://localhost:4000/ICLR2018-Multi_Scale_Dense_Networks/" rel="alternate" type="text/html" title="Multi-Scale DenseNet" /><published>2018-09-10T01:00:00+02:00</published><updated>2018-09-10T01:00:00+02:00</updated><id>http://localhost:4000/ICLR2018-Multi_Scale_Dense_Networks</id><content type="html" xml:base="http://localhost:4000/ICLR2018-Multi_Scale_Dense_Networks/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;iclr-2018---2nd-article&quot;&gt;ICLR 2018 - 2nd article&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;In this series, we explore the 2018 edition of the International Conference
on Learning Representations. Oral papers are analyzed and
commented in an accessible way.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;This article is based on the paper&lt;/em&gt;
&lt;a href=&quot;https://openreview.net/pdf?id=BJ8vJebC-&quot;&gt;Synthetic and natural noise both break Neural Machine Translation&lt;/a&gt;
&lt;em&gt;by Yonatan Belinkov and Yonatan Bisk.&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;If you are reading these lines, there is a good chance that you have been
wandering the Internet for quite some time now. This means that there is also
a good chance that you’ve stumbled upon the &lt;em&gt;Cambridge research&lt;/em&gt; meme:&lt;/p&gt;

&lt;div class=&quot;centeredquote&quot;&gt;
Aoccdrnig to a rscheearch at Cmabrigde Uinervtisy, it deosn't mttaer in waht
oredr the ltteers in a wrod are, the olny iprmoetnt tihng is taht the frist and
lsat ltteer be at the rghit pclae.
&lt;/div&gt;

&lt;p&gt;There is even a greater chance that you have, for more or less legitimate
reasons, used Google Translate (or even better, its European equivalent, DeepL).
Of course, those automated translation systems have improved a lot in the past
few years; what was laughable at a couple years ago is now quite reasonable for
a number of languages. For simple texts, the translation even feels quite
natural, although not idiomatic (try translating “Il tombe des cordes.”, which
is the usual French equivalent of “It’s raining cats and dogs.”).&lt;/p&gt;

&lt;p&gt;Going back to the meme, you would probably have no trouble translating it to
whatever language you are familiar with. But how do automated translation
systems cope with this difficult situation? Let’s try translating a French
version into English:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Source&lt;/th&gt;
      &lt;th&gt;Sentence&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Original &lt;br /&gt;French &lt;br /&gt; scrambled&lt;/td&gt;
      &lt;td&gt;Sleon un cehcruher de l’Uvinertisé de Cmabrigde, l’odrre des ltteers dnas un mot n’a pas d’ipmrotncae, la suele coshe ipmrotnate est que la pmeirère et la drenèire lteetrs sinoet à la bnnoe pclae.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Human translation&lt;/td&gt;
      &lt;td&gt;According to a researcher at Cambridge University, it doesn’t matter in what order the letters in a word are, the only important thing is that the first and last letters are in the right place.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Google Translate&lt;/td&gt;
      &lt;td&gt;According to an opinion of the Uvinised of Cmabrigde, the name of the ltteers in one word does not have a name, but the name of the message is that the letter and the letter are very brief at the same time.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DeepL&lt;/td&gt;
      &lt;td&gt;According to a cehcruher of the Uvinertized of Cmabrigde, the odd of the ltteers in a word has no ipmrotncae, the only coshe ipmrotnate is that the pmeirere and the drenere lteetrs sinoetrs in the bnnoe pclae.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This is quite unconvincing, to say the least. In other words, Google Translation
and DeepL are both very sensitive to this type of noise, whereas humans
seem impressively robust to it. This is just a symptom of the frailty of
automated translation systems:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;While typos and noise are not new to NLP, our systems are rarely trained to
explicitly address them, as we instead hope that the relevant noise will occur
in the training data.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It turns out that this kind of wishful thinking leaves &lt;strong&gt;Neural Machine
Translation (NMT) systems very
brittle&lt;/strong&gt;, with their performance dropping quickly in presence of noise. How can
we evaluate this lack of robustness to noise, and what can be done to improve
our models? Let’s jump into the paper.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;evaluating-the-robustness-of-current-models&quot;&gt;Evaluating the robustness of current models&lt;/h2&gt;

&lt;p&gt;We would like to evaluate the performance of NMT models, and how it is affected
by noise. To do that we will, unsurprisingly, have to answer 3 questions:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Which performance metric?&lt;/li&gt;
  &lt;li&gt;Which NMT models?&lt;/li&gt;
  &lt;li&gt;Which kind of noise?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;the-performance-metric-bleu&quot;&gt;The performance metric: BLEU&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/BLEU&quot;&gt;BLEU&lt;/a&gt; (bilingual evaluation
understudy)&lt;/strong&gt; is a popular metric to evaluate the similarity between the
machine translation and a professional human translation. The idea behind it is
fairly simple: it is a modification of precision, computed on candidate
sentences (by comparison with reference sentences), and then averaged to produce
a corpus-level score of the translation’s quality.&lt;/p&gt;

&lt;p&gt;Let’s first remember why we don’t use precision as metric for this task.
Consider a sentence $s$ to be translated, with human reference translation $r$
and candidate translation $c$. Then precision is a score between 0 and 1
computed as:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\textrm{Precision}(c, r) =
  \dfrac{\sum_{w \in W(c)} m_w(c) \cdot \mathbb{1}_{w \in W(r)}}
    {\sum_{w \in W(c)} m_w(c)}&lt;/script&gt;

&lt;p&gt;with $W(c)$ the set of unique words that appear in $c$, and $m_w(c)$ the number
of occurences of $w$ in $c$. Precision essentially measures the proportion of
words of the candidate translation that actually appear in the reference
translation. To see why this is not sufficient, have a look at the table below.
Usually precision is considered coupled with recall to overcome such issues;
we don’t, because recall can be artificially inflated when considering multiple
references (see &lt;a href=&quot;https://en.wikipedia.org/wiki/BLEU&quot;&gt;here&lt;/a&gt;).&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Reference&lt;/th&gt;
      &lt;th&gt;Candidate&lt;/th&gt;
      &lt;th&gt;Precision&lt;/th&gt;
      &lt;th&gt;BLEU (bigram)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;“I like trains a lot”&lt;/td&gt;
      &lt;td&gt;“I like”&lt;/td&gt;
      &lt;td&gt;$\dfrac{1+1}{2} = 1$&lt;/td&gt;
      &lt;td&gt;$\dfrac{1}{1} \cdot e^{1 - 2/5} = 0.55$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“I like trains a lot”&lt;/td&gt;
      &lt;td&gt;“a a a a a”&lt;/td&gt;
      &lt;td&gt;$\dfrac{5}{5} = 1$&lt;/td&gt;
      &lt;td&gt;$\dfrac{0}{4} \cdot 1 = 0$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“I like trains a lot”&lt;/td&gt;
      &lt;td&gt;“I like trains a a”&lt;/td&gt;
      &lt;td&gt;$\dfrac{5}{5} = 1$&lt;/td&gt;
      &lt;td&gt;$\dfrac{3}{4} \cdot 1 = 0.75$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“It is raining cats and dogs”&lt;/td&gt;
      &lt;td&gt;“It is pouring”&lt;/td&gt;
      &lt;td&gt;$\dfrac{2}{3} = 0.66$&lt;/td&gt;
      &lt;td&gt;$\dfrac{1}{2} \cdot e^{1 - 3/6} = 0.30$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;To solve those issues, the BLEU score brings a couple of modifications to the
precision:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Consider the n-grams $G(c)$ instead of the words $W(c)$. &lt;br /&gt;This helps with
the fluency of the translation: with words only, “trains lot I a like” gets the
same score as “I like trains a lot”.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Replace $\ \ \textrm{ }m_w(c) \cdot 1_{w \in W(r)}\ \ \textrm{ }$ by $\ \
\textrm{ }\min (m_w(c), m_w(r)) \cdot {1_{w \in W(r)}}$. &lt;br /&gt;This basically
says that, in the second example, only the first “a” will be counted as correct,
since “a” appears only once in the reference.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Multiply by a factor $\ \ \min\left(1, \exp \left(1 - \frac{\textrm{length of reference
corpus}} {\textrm{length of candidate corpus}}\right)\right)$. &lt;br /&gt;Indeed, even with the
previous modifications, the constructed score still favors short translations
(see the first example). We therefore penalize translations that are shorter on
average than the reference.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;As illustrated in the last row of the table, even with these modifications the
final score is not ideal, since a perfectly natural candidate translation gets
a low score. It is, however, still much better than precision in a wide range
of situations. In the end, the BLEU score takes the following form
(the higher the better) for our example sentences:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\textrm{BLEU}(c, r) =
  \dfrac{\sum_{g \in G(c)} \min (m_g(r), m_g(c)) \cdot \mathbb{1}_{g \in G(r)}}
    {\sum_{g \in G(c)} m_g(c)}
  \cdot \min\left(1, \exp \left({1 -
  \frac{\textrm{length}(r)}{\textrm{length}(c)}}\right)\right)&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;the-nmt-models-nematus-and-char2char&quot;&gt;The NMT models: &lt;strong&gt;Nematus&lt;/strong&gt; and &lt;strong&gt;char2char&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;This will be much quicker. We want to see how state-of-the-art models
with different architectures (and especially different accesses to words,
sub-word units or characters) are able to cope with noise. The authors ran their
experiments on three distinct models:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1610.03017&quot;&gt;&lt;strong&gt;char2char&lt;/strong&gt;&lt;/a&gt; (Lee et al., 2017) - a
sequence-to-sequence model with attention, trained on characters to characters
(&lt;a href=&quot;https://github.com/nyu-dl/dl4mt-c2c&quot;&gt;implementation&lt;/a&gt;).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://aclweb.org/anthology/E17-3017&quot;&gt;&lt;strong&gt;Nematus&lt;/strong&gt;&lt;/a&gt; (Sennrich et al., 2017) -
a competition-winning sequence-to-sequence model with some architectural
modifications that enable operating on sub-word units
(&lt;a href=&quot;http://data.statmt.org/rsennrich/wmt16_systems/&quot;&gt;implementation&lt;/a&gt;).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1508.06615&quot;&gt;&lt;strong&gt;charCNN&lt;/strong&gt;&lt;/a&gt; (Kim et al., 2015) - an
attentional sequence-to-sequence model based on a character convolutional
neural network. To quote the authors, “this model retains the notion of a word
but learns a character-dependent representation of words”, and “performs well on
morphologically rich languages”
(&lt;a href=&quot;https://github.com/harvardnlp/seq2seq-attn&quot;&gt;implementation&lt;/a&gt;).&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;the-noise-types-nat-key-swap-mid-rand&quot;&gt;The noise types: Nat, Key, Swap, Mid, Rand&lt;/h3&gt;

&lt;p&gt;We finally need to define a number of noise types that we will use to perturb
the models.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Source&lt;/th&gt;
      &lt;th&gt;Example&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Original&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;weather&lt;/td&gt;
      &lt;td&gt;Original correct word&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Nat&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;whether&lt;/td&gt;
      &lt;td&gt;Natural noise, e.g. spelling mistake&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Key&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;qeather&lt;/td&gt;
      &lt;td&gt;Replace a letter with an adjacent key (QWERTY keyboard)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Swap&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;wetaher&lt;/td&gt;
      &lt;td&gt;Swap two letters except the first and last ones&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Mid&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;whaeter&lt;/td&gt;
      &lt;td&gt;Scramble the letters except the first and last ones&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Rand&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;raewhte&lt;/td&gt;
      &lt;td&gt;Scramble all letters&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;facing-the-truth---the-inability-to-translate-noisy-texts&quot;&gt;Facing the truth - the (in)ability to translate noisy texts&lt;/h3&gt;

&lt;p&gt;With all the tools in hand, it is now time to experiment and face the truth:
how well are our NMT models able to cope with the different noise types? I’m
definitely too lazy to run all the tests by myself, so I’ll steal the paper’s
results instead.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-10-noise_results.png&quot; alt=&quot;Experiments with noise&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-10-noise_plots.png&quot; alt=&quot;Performance decrease&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Whatever the language, noise has a striking effect on performance.
As a quick note, the results presented in the table aren’t comparable across
noise types, since the noise intensity is not the same in all cases. For a fair
comparison, have a look at the graphs (German to English): surprisingly enough,
the Rand noise isn’t much worse than Swap, despite yielding much more dramatic
changes of the tokens. It is actually &lt;em&gt;very&lt;/em&gt; surprising, since Swap is strictly
included in Rand. This would mean that the NMT model (especially Nematus)
is basically unable to recover a word with virtually any Swap mistake.
Yet, the authors’ conclusion still holds true:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The important thing to note is that even small amounts of noise lead to
substantial drops in performance. […] This is true for both natural noise and
all kinds of synthetic noise. […] The degradation in quality is especially
severe in light of the humans’ ability to understand noisy texts.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;dealing-with-noise&quot;&gt;Dealing with noise&lt;/h2&gt;

&lt;p&gt;Now that we know where we are, what can be done to increase the robustness of
our models? The authors propose two natural ideas, and show their effect on
performance:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;All models presented rely on word structure to build a representation. This
structure is, however, altered to some extent by most of the studied noise
types (Swap, Mid, Rand). The idea is therefore to make some architectural
modifications in order to learn a representation of words that is invariant to
their structure.&lt;/li&gt;
  &lt;li&gt;Training on noisy examples has been regularly reported to increase model
robustness to noise. Let’s try that too.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;structure-invariant-representations&quot;&gt;Structure invariant representations&lt;/h3&gt;

&lt;p&gt;As is clear in their architecture, all three of the models under study are
&lt;em&gt;by design&lt;/em&gt; sensitive to word structure, at a character level (due to
convolutional layers or the sub-word units considered). There is a fair chance
that a model that is &lt;em&gt;insensitive&lt;/em&gt; to this structure would be more robust to
noises that affect this structure; nothing groundbreaking there.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Perhaps the simplest such model is to take the average character embedding as
a word representation. This model, referred to as meanChar, first generates a
word representation by averaging character embeddings, and then proceeds
with a word-level encoder similar to the charCNN model.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-10-meanchar_performance.png&quot; alt=&quot;meanChar performance&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;center&gt; Performance of meanChar in different settings. By design, Scr is the
same as Vanilla for this model. &lt;/center&gt;

&lt;p&gt;As is clear in the table, meanChar turns out to be pretty good for translating
scrambled text (much better than charCNN). Note that, by design, this model
sees no difference between vanilla and scrambled texts; the Scr performance
reported can therefore be compared to the vanilla performance of other models.
However, meanChar is still very sensitive to Nat and Key noise types, that do
not resemble Rand.&lt;/p&gt;

&lt;h4 id=&quot;personal-notes-on-structure-invariant-and-graph-based-representations&quot;&gt;Personal notes on structure-invariant and graph-based representations&lt;/h4&gt;

&lt;p&gt;To me, this model seems somewhat coarse. While it is true that averaging
all character embeddings removes the reliance on word structure, it also
discards a huge part of the information brought by individual character. Unless
you are using an embedding dimension that is of the order of the size of your
alphabet, the
signal transmitted to the convolutional layer dismisses &lt;em&gt;some&lt;/em&gt; information
about the &lt;em&gt;presence&lt;/em&gt; of individual characters, in addition to throwing away
all information about &lt;em&gt;order&lt;/em&gt;.
In other words, not only anagrams will get the same representation, but also
some totally different words could by random chance.
One could argue that, with a good encoding
(e.g. simply using the powers of 2, which is basically cheating by pretending
that a full-dimensional one-hot vector can be reduced to a 1-dimensional scalar
value), we could always recover the presences; however I cannot think of one
that would suit the convolutional structure of the next layer. To be fair, the
authors themselves conceded, in a response to a reviewer, that “meanChar may
not be the ideal architecture for capturing noise, but it’s a simple,
structure-invariant representation that works reasonably well. We have tried
several other architectures, including a self-attention mechanism, but haven’t
been able to improve beyond it.”&lt;/p&gt;

&lt;p&gt;Have a look at Figures 2 and 3 below, depicting the charCNN vs. meanChar
word representations. I am pretty sure
that a better word representation can be found, discarding only the structure
while preserving the presence (instead of “jeter le bébé avec l’eau du bain”,
like we say in French). A first thought is a complete &lt;strong&gt;graph of individual
characters&lt;/strong&gt; (see Figure 4), with a graph-convolutional layer that would follow.
This seems to me like a more natural generalization of the previous models:
thinking in terms of graphs where nodes are the characters, previous
representations saw a word as a chain of characters, each of them linked only to
the next one by a directed edge. Discarding structure would simply mean linking
all nodes together by undirected edges.&lt;/p&gt;

&lt;p&gt;This could even
be adapted to retain &lt;em&gt;some weak&lt;/em&gt; information about the structure by &lt;strong&gt;weighting
edges&lt;/strong&gt; using the original order (the closer two characters in the original
word, the higher the weight; see Figure 5). These weights would for example play
a role in interaction with regularization, for example $L_2$-regularization on
the coefficients of the convolutional filters (for very low weights, it will
be too expensive to take those into account unless there is a very good reason).
While not completely structure-invariant, this has a potential to make the
model more robust to
structure change, while retaining all information about the presence of
individual characters and not forgetting all about structure like in meanChar.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-10-graph_chain.png&quot; alt=&quot;Graph chain&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;center&gt; &lt;strong&gt;Figure 2&lt;/strong&gt; - `charCNN` word representation
as a chain of character embeddings. &lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-10-graph_meanchar.png&quot; alt=&quot;Graph chain&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;center&gt; &lt;strong&gt;Figure 3&lt;/strong&gt; - `meanChar` word representation as an average
of character embeddings. &lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-10-graph_complete.png&quot; alt=&quot;Graph complete&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;center&gt; &lt;strong&gt;Figure 4&lt;/strong&gt; - `graphChar` word
representation as a complete graph of character embeddings. &lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-10-graph_weighted.png&quot; alt=&quot;Graph weighted&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;center&gt; &lt;strong&gt;Figure 5&lt;/strong&gt; - `w-graphChar` word
representation as a weighted graph of character embeddings. The weights, here
arbitrary, could reflect the structure to some extent. &lt;/center&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;training-on-noisy-texts&quot;&gt;Training on noisy texts&lt;/h3&gt;

&lt;p&gt;Another natural idea is to expose the model to noisy texts during training. I am
not too sure that we can adequately call this &lt;em&gt;black-box adversarial training&lt;/em&gt;
like the authors did, but the concept remains the same: is the model
systematically failing to handle a specific type of inputs? Fine, let’s train
it on some of these specific inputs, and hope that it has the capacity to learn
a relevant pattern.&lt;/p&gt;

&lt;h4 id=&quot;with-meanchar---personal-doubts&quot;&gt;With meanChar - personal doubts&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-10-meanchar_noisy_training.png&quot; alt=&quot;meanChar noisy training&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This is not very convincing. All in all, training on noise type A seems to
improve performance when testing on type A noisy texts in French and German, but
not in Czech. There is no conclusive result in this table. Note that we didn’t
expect meanChar to deal well with Key and Nat noises anyway.&lt;/p&gt;

&lt;p&gt;There is however something quite troubling with this table. Remember that
meanChar is supposedly &lt;em&gt;invariant to word structure&lt;/em&gt;, and should therefore
remain unaffected by Rand noise (scrambling), since the model &lt;em&gt;does not make any
difference between the original word and the scrambled version&lt;/em&gt;. How comes there
is such a huge difference in performance between training on Rand+Key and on Key
alone? What’s more, this difference is not even consistent across languages.
Rand is affecting the training way too much, which means &lt;strong&gt;one of the following
is wrong: the implementation, the results (including their expected stability),
or my understanding of the paper&lt;/strong&gt;. I’d rather it be the latter.&lt;/p&gt;

&lt;h4 id=&quot;with-charcnn---insights-on-the-filters&quot;&gt;With charCNN - insights on the filters&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-10-charcnn_noisy_training.png&quot; alt=&quot;charCNN noisy training&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;More extensive experiments show that the more complicated charCNN is, generally
speaking, &lt;strong&gt;robust to the noise types is was exposed to during training, and
only those&lt;/strong&gt;. Additionally, except when trained on Nat noise alone, all charCNN
models keep good performance on vanilla test texts. A model trained on all noise
types mixed is not the best in any specific setting, but is the best on average.&lt;/p&gt;

&lt;p&gt;From these results, the authors draw three major insights:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;When trained on a mix of different noise types, the charCNN is robust to all
noise types that it has been exposed to. In particular, the model trained on
Rand+Key+Nat shows good performance in all settings, and gives (according to
the authors) a reasonable translation of the Cambridge meme:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;centeredquote&quot;&gt;
According to a study of Cambridge University, it doesn't matter
which technology in a word is going to get the letters in a word that is the
only important thing for the first and last letter.
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;When trained on synthetic noise, no charCNN model was able to correctly handle
natural noise. This is actually a huge problem, since natural noise is what we
mostly care about, while synthetic noise is what we can easily generate. More
on that in the next section.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;It is puzzling that, despite the sensitivity of convolutions to the structure
of the input, charCNN is able to perform well on scrambled texts when trained
on the corresponding noise.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let us dwell a bit more on the last point. The authors propose an interesting
analysis of the convolution filters learned in different settings. They
investigate, one dimension (out of the 25 of character embeddings) at a time,
what the variance of the weights of the filters are. Their idea is the
following: in the scrambled setting, their is no pattern to detect in the
character ordering; therefore the variance of weights along a given dimension
of the character embeddings should be low, i.e. those weights should lie close
to one another.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-10-weight_variances.png&quot; alt=&quot;Weight variances&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To test their hypothesis, the authors take, for each filter (out of 1000) and
each embedding dimension (out of 25), the variance of the weights across the
filter width (6 characters). Intuitively, we expect this variance to be small
when the filter is close to being uniform, that is, when the filter is actually
performing an average of the embeddings over this specific dimension.
They then average these variances across the
filters, yielding 25 average variances, which are plotted above.&lt;/p&gt;

&lt;p&gt;These results tend to support the hypothesis, although I disagree with the
authors’ assertion that “low average variance means that different filters tend
to learn similar behavior, while high average variance means that they learn
different patterns”. From my understanding, high average variance means that
many filters tend to learn a non-uniform pattern, yielding many high individual
variances, and a high average. For example, if all filters learned were
$[1,2,3,4,5,6]$, the average variance would be equal to the individual variance
of $2.9$, which is quite high; nonetheless, all filters learn the same exact
pattern. I would also like to note that small variance does not always mean
uniform behavior, and that variances can not be so easily compared. For example,
if all filters learned were $[0.1,0.2,0.3,0.4,0.5,0.6]$, the variance would be
$0.029$, which is much lower than the previous one; yet it is not obvious that
the filters learned correspond to a more uniform pattern than the previous case.
I doubt however that there is such a scale difference in the actual models
trained, so I would buy the authors’ interpretation:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[…] with random scrambling there are no patterns to detect in the data, so
filters resort to close to uniform weights. [… Moreover], in the Rand model,
the variance of variances [size of the box] is close to zero, indicating that in
all character embedding dimensions the learned weights are of small variance;
[…] the model learned to reproduce a representation similar to the meanChar
model.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;in-the-end-a-call-for-better-noise&quot;&gt;In the end, a call for better noise&lt;/h2&gt;

&lt;p&gt;Let’s recap. In the major field of Neural Machine Translation, state-of-the-art
models fail to correctly handle even a small amount of noise. This holds true
for a variety of noise types, including altering the order of letters in a word,
key swapping based on keyboard proximity, and natural noise. While scrambling
noise can be correctly handled by structure invariant word representation, such
as an average of character embeddings (see the meanChar model), it remains
challenging to develop models that are robust to key swapping and natural noise.
Training the model on noisy texts yields an increased robustness to the noise
types that the model has been exposed to, but decreases general performance,
calling for better representations, architectures and understanding of the
effect of noise, in order to develop satisfyingly robust models, that could
approach human insensitivity to noise in natural language processing.&lt;/p&gt;

&lt;p&gt;One point in particular stands out of the paper: natural noise can not be
handled by training on synthetic noise. Moreover, it appears that the former
qualitatively differs from the latter, being mostly composed of phonological
mistakes, character omissions, and incorrect conjugations of verbs. This is a
major issue, since natural noise is what we ultimately (in most cases) care
about, and synthetic noise is what we are able to easily generate (hence to
gather data on). The lack of mechanisms to generate realistic natural human
errors in an automatic way remains a huge issue. All in all:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;We believe that more work is necessary in order to immune NMT models against
natural noise. As corpora with natural noise are limited, another approach to
future work is to design better NMT architectures that would be robust to noise
without seeing it in the training data.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I personally trust that we will eventually find a good NMT model
paradigm that will enable correct translation of both scrambling noise, through
structure invariant (or less sensitive) word representation, and key swapping,
by integrating a confusion matrix (built from the keyboard) to the character
embeddings. However, I think it is still a long way until we find architectures
that can handle natural noise without being previously trained on it, so I would
vote for algorithms to generate more realistic synthetic noise.&lt;/p&gt;</content><author><name>Romain Girard</name></author><category term="ICLR 2018" /><category term="Resource efficiency" /><category term="CNN" /><category term="Network architecture" /><category term="ICLR" /><summary type="html"></summary></entry><entry><title type="html">Neural Machine Translation of the Cambridge meme</title><link href="http://localhost:4000/ICLR_2-nmt_cambridge_meme/" rel="alternate" type="text/html" title="Neural Machine Translation of the Cambridge meme" /><published>2018-09-10T01:00:00+02:00</published><updated>2018-09-10T01:00:00+02:00</updated><id>http://localhost:4000/ICLR_2-nmt_cambridge_meme</id><content type="html" xml:base="http://localhost:4000/ICLR_2-nmt_cambridge_meme/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;iclr-2018---2nd-article&quot;&gt;ICLR 2018 - 2nd article&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;In this series, we explore the 2018 edition of the International Conference
on Learning Representations. Oral papers are analyzed and
commented in an accessible way.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;This article is based on the paper&lt;/em&gt;
&lt;a href=&quot;https://openreview.net/pdf?id=BJ8vJebC-&quot;&gt;Synthetic and natural noise both break Neural Machine Translation&lt;/a&gt;
&lt;em&gt;by Yonatan Belinkov and Yonatan Bisk.&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;If you are reading these lines, there is a good chance that you have been
wandering the Internet for quite some time now. This means that there is also
a good chance that you’ve stumbled upon the &lt;em&gt;Cambridge research&lt;/em&gt; meme:&lt;/p&gt;

&lt;div class=&quot;centeredquote&quot;&gt;
Aoccdrnig to a rscheearch at Cmabrigde Uinervtisy, it deosn't mttaer in waht
oredr the ltteers in a wrod are, the olny iprmoetnt tihng is taht the frist and
lsat ltteer be at the rghit pclae.
&lt;/div&gt;

&lt;p&gt;There is even a greater chance that you have, for more or less legitimate
reasons, used Google Translate (or even better, its European equivalent, DeepL).
Of course, those automated translation systems have improved a lot in the past
few years; what was laughable at a couple years ago is now quite reasonable for
a number of languages. For simple texts, the translation even feels quite
natural, although not idiomatic (try translating “Il tombe des cordes.”, which
is the usual French equivalent of “It’s raining cats and dogs.”).&lt;/p&gt;

&lt;p&gt;Going back to the meme, you would probably have no trouble translating it to
whatever language you are familiar with. But how do automated translation
systems cope with this difficult situation? Let’s try translating a French
version into English:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Source&lt;/th&gt;
      &lt;th&gt;Sentence&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Original &lt;br /&gt;French &lt;br /&gt; scrambled&lt;/td&gt;
      &lt;td&gt;Sleon un cehcruher de l’Uvinertisé de Cmabrigde, l’odrre des ltteers dnas un mot n’a pas d’ipmrotncae, la suele coshe ipmrotnate est que la pmeirère et la drenèire lteetrs sinoet à la bnnoe pclae.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Human translation&lt;/td&gt;
      &lt;td&gt;According to a researcher at Cambridge University, it doesn’t matter in what order the letters in a word are, the only important thing is that the first and last letters are in the right place.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Google Translate&lt;/td&gt;
      &lt;td&gt;According to an opinion of the Uvinised of Cmabrigde, the name of the ltteers in one word does not have a name, but the name of the message is that the letter and the letter are very brief at the same time.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DeepL&lt;/td&gt;
      &lt;td&gt;According to a cehcruher of the Uvinertized of Cmabrigde, the odd of the ltteers in a word has no ipmrotncae, the only coshe ipmrotnate is that the pmeirere and the drenere lteetrs sinoetrs in the bnnoe pclae.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This is quite unconvincing, to say the least. In other words, Google Translation
and DeepL are both very sensitive to this type of noise, whereas humans
seem impressively robust to it. This is just a symptom of the frailty of
automated translation systems:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;While typos and noise are not new to NLP, our systems are rarely trained to
explicitly address them, as we instead hope that the relevant noise will occur
in the training data.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It turns out that this kind of wishful thinking leaves &lt;strong&gt;Neural Machine
Translation (NMT) systems very
brittle&lt;/strong&gt;, with their performance dropping quickly in presence of noise. How can
we evaluate this lack of robustness to noise, and what can be done to improve
our models? Let’s jump into the paper.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;evaluating-the-robustness-of-current-models&quot;&gt;Evaluating the robustness of current models&lt;/h2&gt;

&lt;p&gt;We would like to evaluate the performance of NMT models, and how it is affected
by noise. To do that we will, unsurprisingly, have to answer 3 questions:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Which performance metric?&lt;/li&gt;
  &lt;li&gt;Which NMT models?&lt;/li&gt;
  &lt;li&gt;Which kind of noise?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;the-performance-metric-bleu&quot;&gt;The performance metric: BLEU&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/BLEU&quot;&gt;BLEU&lt;/a&gt; (bilingual evaluation
understudy)&lt;/strong&gt; is a popular metric to evaluate the similarity between the
machine translation and a professional human translation. The idea behind it is
fairly simple: it is a modification of precision, computed on candidate
sentences (by comparison with reference sentences), and then averaged to produce
a corpus-level score of the translation’s quality.&lt;/p&gt;

&lt;p&gt;Let’s first remember why we don’t use precision as metric for this task.
Consider a sentence $s$ to be translated, with human reference translation $r$
and candidate translation $c$. Then precision is a score between 0 and 1
computed as:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\textrm{Precision}(c, r) =
  \dfrac{\sum_{w \in W(c)} m_w(c) \cdot \mathbb{1}_{w \in W(r)}}
    {\sum_{w \in W(c)} m_w(c)}&lt;/script&gt;

&lt;p&gt;with $W(c)$ the set of unique words that appear in $c$, and $m_w(c)$ the number
of occurences of $w$ in $c$. Precision essentially measures the proportion of
words of the candidate translation that actually appear in the reference
translation. To see why this is not sufficient, have a look at the table below.
Usually precision is considered coupled with recall to overcome such issues;
we don’t, because recall can be artificially inflated when considering multiple
references (see &lt;a href=&quot;https://en.wikipedia.org/wiki/BLEU&quot;&gt;here&lt;/a&gt;).&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Reference&lt;/th&gt;
      &lt;th&gt;Candidate&lt;/th&gt;
      &lt;th&gt;Precision&lt;/th&gt;
      &lt;th&gt;BLEU (bigram)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;“I like trains a lot”&lt;/td&gt;
      &lt;td&gt;“I like”&lt;/td&gt;
      &lt;td&gt;$\dfrac{1+1}{2} = 1$&lt;/td&gt;
      &lt;td&gt;$\dfrac{1}{1} \cdot e^{1 - 2/5} = 0.55$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“I like trains a lot”&lt;/td&gt;
      &lt;td&gt;“a a a a a”&lt;/td&gt;
      &lt;td&gt;$\dfrac{5}{5} = 1$&lt;/td&gt;
      &lt;td&gt;$\dfrac{0}{4} \cdot 1 = 0$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“I like trains a lot”&lt;/td&gt;
      &lt;td&gt;“I like trains a a”&lt;/td&gt;
      &lt;td&gt;$\dfrac{5}{5} = 1$&lt;/td&gt;
      &lt;td&gt;$\dfrac{3}{4} \cdot 1 = 0.75$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“It is raining cats and dogs”&lt;/td&gt;
      &lt;td&gt;“It is pouring”&lt;/td&gt;
      &lt;td&gt;$\dfrac{2}{3} = 0.66$&lt;/td&gt;
      &lt;td&gt;$\dfrac{1}{2} \cdot e^{1 - 3/6} = 0.30$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;To solve those issues, the BLEU score brings a couple of modifications to the
precision:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Consider the n-grams $G(c)$ instead of the words $W(c)$. &lt;br /&gt;This helps with
the fluency of the translation: with words only, “trains lot I a like” gets the
same score as “I like trains a lot”.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Replace $\ \ \textrm{ }m_w(c) \cdot 1_{w \in W(r)}\ \ \textrm{ }$ by $\ \
\textrm{ }\min (m_w(c), m_w(r)) \cdot {1_{w \in W(r)}}$. &lt;br /&gt;This basically
says that, in the second example, only the first “a” will be counted as correct,
since “a” appears only once in the reference.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Multiply by a factor $\ \ \min\left(1, \exp \left(1 - \frac{\textrm{length of reference
corpus}} {\textrm{length of candidate corpus}}\right)\right)$. &lt;br /&gt;Indeed, even with the
previous modifications, the constructed score still favors short translations
(see the first example). We therefore penalize translations that are shorter on
average than the reference.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;As illustrated in the last row of the table, even with these modifications the
final score is not ideal, since a perfectly natural candidate translation gets
a low score. It is, however, still much better than precision in a wide range
of situations. In the end, the BLEU score takes the following form
(the higher the better) for our example sentences:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\textrm{BLEU}(c, r) =
  \dfrac{\sum_{g \in G(c)} \min (m_g(r), m_g(c)) \cdot \mathbb{1}_{g \in G(r)}}
    {\sum_{g \in G(c)} m_g(c)}
  \cdot \min\left(1, \exp \left({1 -
  \frac{\textrm{length}(r)}{\textrm{length}(c)}}\right)\right)&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;the-nmt-models-nematus-and-char2char&quot;&gt;The NMT models: &lt;strong&gt;Nematus&lt;/strong&gt; and &lt;strong&gt;char2char&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;This will be much quicker. We want to see how state-of-the-art models
with different architectures (and especially different accesses to words,
sub-word units or characters) are able to cope with noise. The authors ran their
experiments on three distinct models:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1610.03017&quot;&gt;&lt;strong&gt;char2char&lt;/strong&gt;&lt;/a&gt; (Lee et al., 2017) - a
sequence-to-sequence model with attention, trained on characters to characters
(&lt;a href=&quot;https://github.com/nyu-dl/dl4mt-c2c&quot;&gt;implementation&lt;/a&gt;).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://aclweb.org/anthology/E17-3017&quot;&gt;&lt;strong&gt;Nematus&lt;/strong&gt;&lt;/a&gt; (Sennrich et al., 2017) -
a competition-winning sequence-to-sequence model with some architectural
modifications that enable operating on sub-word units
(&lt;a href=&quot;http://data.statmt.org/rsennrich/wmt16_systems/&quot;&gt;implementation&lt;/a&gt;).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1508.06615&quot;&gt;&lt;strong&gt;charCNN&lt;/strong&gt;&lt;/a&gt; (Kim et al., 2015) - an
attentional sequence-to-sequence model based on a character convolutional
neural network. To quote the authors, “this model retains the notion of a word
but learns a character-dependent representation of words”, and “performs well on
morphologically rich languages”
(&lt;a href=&quot;https://github.com/harvardnlp/seq2seq-attn&quot;&gt;implementation&lt;/a&gt;).&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;the-noise-types-nat-key-swap-mid-rand&quot;&gt;The noise types: Nat, Key, Swap, Mid, Rand&lt;/h3&gt;

&lt;p&gt;We finally need to define a number of noise types that we will use to perturb
the models.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Source&lt;/th&gt;
      &lt;th&gt;Example&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Original&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;weather&lt;/td&gt;
      &lt;td&gt;Original correct word&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Nat&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;whether&lt;/td&gt;
      &lt;td&gt;Natural noise, e.g. spelling mistake&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Key&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;qeather&lt;/td&gt;
      &lt;td&gt;Replace a letter with an adjacent key (QWERTY keyboard)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Swap&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;wetaher&lt;/td&gt;
      &lt;td&gt;Swap two letters except the first and last ones&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Mid&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;whaeter&lt;/td&gt;
      &lt;td&gt;Scramble the letters except the first and last ones&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Rand&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;raewhte&lt;/td&gt;
      &lt;td&gt;Scramble all letters&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;facing-the-truth---the-inability-to-translate-noisy-texts&quot;&gt;Facing the truth - the (in)ability to translate noisy texts&lt;/h3&gt;

&lt;p&gt;With all the tools in hand, it is now time to experiment and face the truth:
how well are our NMT models able to cope with the different noise types? I’m
definitely too lazy to run all the tests by myself, so I’ll steal the paper’s
results instead.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-10-noise_results.png&quot; alt=&quot;Experiments with noise&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-10-noise_plots.png&quot; alt=&quot;Performance decrease&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Whatever the language, noise has a striking effect on performance.
As a quick note, the results presented in the table aren’t comparable across
noise types, since the noise intensity is not the same in all cases. For a fair
comparison, have a look at the graphs (German to English): surprisingly enough,
the Rand noise isn’t much worse than Swap, despite yielding much more dramatic
changes of the tokens. It is actually &lt;em&gt;very&lt;/em&gt; surprising, since Swap is strictly
included in Rand. This would mean that the NMT model (especially Nematus)
is basically unable to recover a word with virtually any Swap mistake.
Yet, the authors’ conclusion still holds true:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The important thing to note is that even small amounts of noise lead to
substantial drops in performance. […] This is true for both natural noise and
all kinds of synthetic noise. […] The degradation in quality is especially
severe in light of the humans’ ability to understand noisy texts.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;dealing-with-noise&quot;&gt;Dealing with noise&lt;/h2&gt;

&lt;p&gt;Now that we know where we are, what can be done to increase the robustness of
our models? The authors propose two natural ideas, and show their effect on
performance:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;All models presented rely on word structure to build a representation. This
structure is, however, altered to some extent by most of the studied noise
types (Swap, Mid, Rand). The idea is therefore to make some architectural
modifications in order to learn a representation of words that is invariant to
their structure.&lt;/li&gt;
  &lt;li&gt;Training on noisy examples has been regularly reported to increase model
robustness to noise. Let’s try that too.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;structure-invariant-representations&quot;&gt;Structure invariant representations&lt;/h3&gt;

&lt;p&gt;As is clear in their architecture, all three of the models under study are
&lt;em&gt;by design&lt;/em&gt; sensitive to word structure, at a character level (due to
convolutional layers or the sub-word units considered). There is a fair chance
that a model that is &lt;em&gt;insensitive&lt;/em&gt; to this structure would be more robust to
noises that affect this structure; nothing groundbreaking there.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Perhaps the simplest such model is to take the average character embedding as
a word representation. This model, referred to as meanChar, first generates a
word representation by averaging character embeddings, and then proceeds
with a word-level encoder similar to the charCNN model.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-10-meanchar_performance.png&quot; alt=&quot;meanChar performance&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;center&gt; Performance of meanChar in different settings. By design, Scr is the
same as Vanilla for this model. &lt;/center&gt;

&lt;p&gt;As is clear in the table, meanChar turns out to be pretty good for translating
scrambled text (much better than charCNN). Note that, by design, this model
sees no difference between vanilla and scrambled texts; the Scr performance
reported can therefore be compared to the vanilla performance of other models.
However, meanChar is still very sensitive to Nat and Key noise types, that do
not resemble Rand.&lt;/p&gt;

&lt;h4 id=&quot;personal-notes-on-structure-invariant-and-graph-based-representations&quot;&gt;Personal notes on structure-invariant and graph-based representations&lt;/h4&gt;

&lt;p&gt;To me, this model seems somewhat coarse. While it is true that averaging
all character embeddings removes the reliance on word structure, it also
discards a huge part of the information brought by individual character. Unless
you are using an embedding dimension that is of the order of the size of your
alphabet, the
signal transmitted to the convolutional layer dismisses &lt;em&gt;some&lt;/em&gt; information
about the &lt;em&gt;presence&lt;/em&gt; of individual characters, in addition to throwing away
all information about &lt;em&gt;order&lt;/em&gt;.
In other words, not only anagrams will get the same representation, but also
some totally different words could by random chance.
One could argue that, with a good encoding
(e.g. simply using the powers of 2, which is basically cheating by pretending
that a full-dimensional one-hot vector can be reduced to a 1-dimensional scalar
value), we could always recover the presences; however I cannot think of one
that would suit the convolutional structure of the next layer. To be fair, the
authors themselves conceded, in a response to a reviewer, that “meanChar may
not be the ideal architecture for capturing noise, but it’s a simple,
structure-invariant representation that works reasonably well. We have tried
several other architectures, including a self-attention mechanism, but haven’t
been able to improve beyond it.”&lt;/p&gt;

&lt;p&gt;Have a look at Figures 2 and 3 below, depicting the charCNN vs. meanChar
word representations. I am pretty sure
that a better word representation can be found, discarding only the structure
while preserving the presence (instead of “jeter le bébé avec l’eau du bain”,
like we say in French). A first thought is a complete &lt;strong&gt;graph of individual
characters&lt;/strong&gt; (see Figure 4), with a graph-convolutional layer that would follow.
This seems to me like a more natural generalization of the previous models:
thinking in terms of graphs where nodes are the characters, previous
representations saw a word as a chain of characters, each of them linked only to
the next one by a directed edge. Discarding structure would simply mean linking
all nodes together by undirected edges.&lt;/p&gt;

&lt;p&gt;This could even
be adapted to retain &lt;em&gt;some weak&lt;/em&gt; information about the structure by &lt;strong&gt;weighting
edges&lt;/strong&gt; using the original order (the closer two characters in the original
word, the higher the weight; see Figure 5). These weights would for example play
a role in interaction with regularization, for example $L_2$-regularization on
the coefficients of the convolutional filters (for very low weights, it will
be too expensive to take those into account unless there is a very good reason).
While not completely structure-invariant, this has a potential to make the
model more robust to
structure change, while retaining all information about the presence of
individual characters and not forgetting all about structure like in meanChar.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-10-graph_chain.png&quot; alt=&quot;Graph chain&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;center&gt; &lt;strong&gt;Figure 2&lt;/strong&gt; - `charCNN` word representation
as a chain of character embeddings. &lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-10-graph_meanchar.png&quot; alt=&quot;Graph chain&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;center&gt; &lt;strong&gt;Figure 3&lt;/strong&gt; - `meanChar` word representation as an average
of character embeddings. &lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-10-graph_complete.png&quot; alt=&quot;Graph complete&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;center&gt; &lt;strong&gt;Figure 4&lt;/strong&gt; - `graphChar` word
representation as a complete graph of character embeddings. &lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-10-graph_weighted.png&quot; alt=&quot;Graph weighted&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;center&gt; &lt;strong&gt;Figure 5&lt;/strong&gt; - `w-graphChar` word
representation as a weighted graph of character embeddings. The weights, here
arbitrary, could reflect the structure to some extent. &lt;/center&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;training-on-noisy-texts&quot;&gt;Training on noisy texts&lt;/h3&gt;

&lt;p&gt;Another natural idea is to expose the model to noisy texts during training. I am
not too sure that we can adequately call this &lt;em&gt;black-box adversarial training&lt;/em&gt;
like the authors did, but the concept remains the same: is the model
systematically failing to handle a specific type of inputs? Fine, let’s train
it on some of these specific inputs, and hope that it has the capacity to learn
a relevant pattern.&lt;/p&gt;

&lt;h4 id=&quot;with-meanchar---personal-doubts&quot;&gt;With meanChar - personal doubts&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-10-meanchar_noisy_training.png&quot; alt=&quot;meanChar noisy training&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This is not very convincing. All in all, training on noise type A seems to
improve performance when testing on type A noisy texts in French and German, but
not in Czech. There is no conclusive result in this table. Note that we didn’t
expect meanChar to deal well with Key and Nat noises anyway.&lt;/p&gt;

&lt;p&gt;There is however something quite troubling with this table. Remember that
meanChar is supposedly &lt;em&gt;invariant to word structure&lt;/em&gt;, and should therefore
remain unaffected by Rand noise (scrambling), since the model &lt;em&gt;does not make any
difference between the original word and the scrambled version&lt;/em&gt;. How comes there
is such a huge difference in performance between training on Rand+Key and on Key
alone? What’s more, this difference is not even consistent across languages.
Rand is affecting the training way too much, which means &lt;strong&gt;one of the following
is wrong: the implementation, the results (including their expected stability),
or my understanding of the paper&lt;/strong&gt;. I’d rather it be the latter.&lt;/p&gt;

&lt;h4 id=&quot;with-charcnn---insights-on-the-filters&quot;&gt;With charCNN - insights on the filters&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-10-charcnn_noisy_training.png&quot; alt=&quot;charCNN noisy training&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;More extensive experiments show that the more complicated charCNN is, generally
speaking, &lt;strong&gt;robust to the noise types is was exposed to during training, and
only those&lt;/strong&gt;. Additionally, except when trained on Nat noise alone, all charCNN
models keep good performance on vanilla test texts. A model trained on all noise
types mixed is not the best in any specific setting, but is the best on average.&lt;/p&gt;

&lt;p&gt;From these results, the authors draw three major insights:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;When trained on a mix of different noise types, the charCNN is robust to all
noise types that it has been exposed to. In particular, the model trained on
Rand+Key+Nat shows good performance in all settings, and gives (according to
the authors) a reasonable translation of the Cambridge meme:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;centeredquote&quot;&gt;
According to a study of Cambridge University, it doesn't matter
which technology in a word is going to get the letters in a word that is the
only important thing for the first and last letter.
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;When trained on synthetic noise, no charCNN model was able to correctly handle
natural noise. This is actually a huge problem, since natural noise is what we
mostly care about, while synthetic noise is what we can easily generate. More
on that in the next section.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;It is puzzling that, despite the sensitivity of convolutions to the structure
of the input, charCNN is able to perform well on scrambled texts when trained
on the corresponding noise.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let us dwell a bit more on the last point. The authors propose an interesting
analysis of the convolution filters learned in different settings. They
investigate, one dimension (out of the 25 of character embeddings) at a time,
what the variance of the weights of the filters are. Their idea is the
following: in the scrambled setting, their is no pattern to detect in the
character ordering; therefore the variance of weights along a given dimension
of the character embeddings should be low, i.e. those weights should lie close
to one another.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-10-weight_variances.png&quot; alt=&quot;Weight variances&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To test their hypothesis, the authors take, for each filter (out of 1000) and
each embedding dimension (out of 25), the variance of the weights across the
filter width (6 characters). Intuitively, we expect this variance to be small
when the filter is close to being uniform, that is, when the filter is actually
performing an average of the embeddings over this specific dimension.
They then average these variances across the
filters, yielding 25 average variances, which are plotted above.&lt;/p&gt;

&lt;p&gt;These results tend to support the hypothesis, although I disagree with the
authors’ assertion that “low average variance means that different filters tend
to learn similar behavior, while high average variance means that they learn
different patterns”. From my understanding, high average variance means that
many filters tend to learn a non-uniform pattern, yielding many high individual
variances, and a high average. For example, if all filters learned were
$[1,2,3,4,5,6]$, the average variance would be equal to the individual variance
of $2.9$, which is quite high; nonetheless, all filters learn the same exact
pattern. I would also like to note that small variance does not always mean
uniform behavior, and that variances can not be so easily compared. For example,
if all filters learned were $[0.1,0.2,0.3,0.4,0.5,0.6]$, the variance would be
$0.029$, which is much lower than the previous one; yet it is not obvious that
the filters learned correspond to a more uniform pattern than the previous case.
I doubt however that there is such a scale difference in the actual models
trained, so I would buy the authors’ interpretation:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[…] with random scrambling there are no patterns to detect in the data, so
filters resort to close to uniform weights. [… Moreover], in the Rand model,
the variance of variances [size of the box] is close to zero, indicating that in
all character embedding dimensions the learned weights are of small variance;
[…] the model learned to reproduce a representation similar to the meanChar
model.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;in-the-end-a-call-for-better-noise&quot;&gt;In the end, a call for better noise&lt;/h2&gt;

&lt;p&gt;Let’s recap. In the major field of Neural Machine Translation, state-of-the-art
models fail to correctly handle even a small amount of noise. This holds true
for a variety of noise types, including altering the order of letters in a word,
key swapping based on keyboard proximity, and natural noise. While scrambling
noise can be correctly handled by structure invariant word representation, such
as an average of character embeddings (see the meanChar model), it remains
challenging to develop models that are robust to key swapping and natural noise.
Training the model on noisy texts yields an increased robustness to the noise
types that the model has been exposed to, but decreases general performance,
calling for better representations, architectures and understanding of the
effect of noise, in order to develop satisfyingly robust models, that could
approach human insensitivity to noise in natural language processing.&lt;/p&gt;

&lt;p&gt;One point in particular stands out of the paper: natural noise can not be
handled by training on synthetic noise. Moreover, it appears that the former
qualitatively differs from the latter, being mostly composed of phonological
mistakes, character omissions, and incorrect conjugations of verbs. This is a
major issue, since natural noise is what we ultimately (in most cases) care
about, and synthetic noise is what we are able to easily generate (hence to
gather data on). The lack of mechanisms to generate realistic natural human
errors in an automatic way remains a huge issue. All in all:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;We believe that more work is necessary in order to immune NMT models against
natural noise. As corpora with natural noise are limited, another approach to
future work is to design better NMT architectures that would be robust to noise
without seeing it in the training data.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I personally trust that we will eventually find a good NMT model
paradigm that will enable correct translation of both scrambling noise, through
structure invariant (or less sensitive) word representation, and key swapping,
by integrating a confusion matrix (built from the keyboard) to the character
embeddings. However, I think it is still a long way until we find architectures
that can handle natural noise without being previously trained on it, so I would
vote for algorithms to generate more realistic synthetic noise.&lt;/p&gt;</content><author><name>Romain Girard</name></author><category term="ICLR 2018" /><category term="Neural Machine Translation" /><category term="Noise" /><category term="NLP" /><category term="ICLR" /><summary type="html"></summary></entry><entry><title type="html">The Gini coefficient is not the best inequality metric</title><link href="http://localhost:4000/gini-coefficient/" rel="alternate" type="text/html" title="The Gini coefficient is not the best inequality metric" /><published>2018-08-21T00:00:00+02:00</published><updated>2018-08-21T00:00:00+02:00</updated><id>http://localhost:4000/gini-coefficient</id><content type="html" xml:base="http://localhost:4000/gini-coefficient/">&lt;p&gt;Or is it?&lt;/p&gt;

&lt;p&gt;I’d like this thing not to be included&lt;/p&gt;</content><author><name>Romain Girard</name></author><category term="Miscellaneous" /><category term="Econometrics" /><category term="Inequality" /><category term="Atkinson" /><summary type="html">Or is it?</summary></entry><entry><title type="html">Adam’s convergence proof is flawed</title><link href="http://localhost:4000/ICLR/" rel="alternate" type="text/html" title="Adam's convergence proof is flawed" /><published>2018-08-19T01:00:00+02:00</published><updated>2018-08-19T01:00:00+02:00</updated><id>http://localhost:4000/ICLR</id><content type="html" xml:base="http://localhost:4000/ICLR/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;iclr-2018---1st-article&quot;&gt;ICLR 2018 - 1st article&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;In this series, we explore the 2018 edition of the International Conference
on Learning Representations. Oral papers are analyzed and
commented in an accessible way.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;This article is based on the paper&lt;/em&gt;
&lt;a href=&quot;https://openreview.net/pdf?id=ryQu7f-RZ&quot;&gt;On the convergence of Adam and beyond&lt;/a&gt;
&lt;em&gt;by Sashank J. Reddi, Satyen Kale, and Sanjiv Kumar.&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;If you asked people in the deep learning community what their favorite optimization
algorithm is, you’d probably see &lt;a href=&quot;https://arxiv.org/abs/1412.6980&quot;&gt;Adam&lt;/a&gt;
in the top 2 (with Stochastic gradient descent + momentum),
far ahead of alternatives like Adagrad or RMSProp (we’ll come to
these in a minute). &lt;b&gt;Adam has become very popular in deep
learning since it was proposed by Kingma &amp;amp; Ba in December 2014&lt;/b&gt;.
The reasons are easy to
understand: it exhibits impressive performance, uses many important ideas of
previous works, comes with predefined settings that already work very well,
and does not require careful hyper-parameter tuning.
&lt;em&gt;Better performance with less work, what more do you want?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Naturally, great power comes with great responsibilities, even for optimization
algorithms like Adam. At the very least, we expect some theoretical guarantees
on the convergence properties, to make sure that the algorithm is actually doing
its job when required. This is a necessary sanity check, confirming by
the maths that we can legitimately have faith in its correctness.&lt;/p&gt;

&lt;p&gt;The convergence proof was provided in the original Adam paper.
However, our authors show in their paper that &lt;strong&gt;this original proof is flawed,
and Adam does not correctly converge in all problems&lt;/strong&gt;, as illustrated by this
theorem:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Theorem 3.&lt;/strong&gt; [With mild assumptions on the parameters], there is a
stochastic convex optimization problem for which Adam does not converge to the
optimal solution.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;How did we reach this point, where the most widely used
optimization algorithm in deep learning does not converge in some simple
convex problems? Let’s go back some years, and see what lead us there.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;gradient-descent-and-adaptive-methods&quot;&gt;Gradient descent and adaptive methods&lt;/h2&gt;

&lt;p&gt;To facilitate analysis, let’s define our online optimization framework.
At each time step $t$:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The algorithm picks a
point $x_t$ (weights of the model) in the feasible set $\mathcal{F}$.&lt;/li&gt;
  &lt;li&gt;We then
get access to the next mini-batch, with the associated loss function $f_t$,
and we incur the loss $f_t(x_t)$.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Usually, our goal is to find an optimal
parameter $x$ such that the loss $f(x)$ on the entire training set is minimal
(intermediate loss functions $f_t$ are used as stochastic approximations of
$f$). Here, in the (equivalent) online setup, the goal
is to &lt;strong&gt;minimize the total regret at time $T$&lt;/strong&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;R_T = \sum_{i=1}^T f_t(x_t) - \min_{x \in
\mathcal{F}} \left(\sum_{i=1}^T f_t(x)\right)&lt;/script&gt;

&lt;p&gt;A large number of optimization algorithms were proposed to achieve this goal.
For a detailed and intuitive overview (and introduction to gradient descent),
I recommend this excellent
&lt;a href=&quot;http://ruder.io/optimizing-gradient-descent/index.html&quot;&gt;blog post&lt;/a&gt; by Sebastian
Ruder. We will just quickly go over a couple major steps that lead us to Adam.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Mini-batch/Stochastic gradient descent&lt;/strong&gt; is the first variant of gradient
descent that actually works decently well in deep learning. In our online setup,
it is reframed as &lt;em&gt;online gradient descent&lt;/em&gt;, where the points $x_t$ are updated
by moving in the opposite direction of the gradient $g_t = \nabla f_t(x_t)$,
computed on the available mini-batch. The update size is determined by a
learning rate $\alpha_t$ (typically $\alpha/\sqrt{t}$ for some $\alpha$),
and the result is projected back to the feasible set thanks to the projection
operator $\Pi_{\mathcal{F}}$. &lt;br /&gt;
We thus get the &lt;strong&gt;update rule of SGD:
$\ x_{t+1} = \Pi_\mathcal{F}(x_t - \alpha_t g_t)$&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Although the convergence of SGD requires a decreasing learning rate, choosing
an adequate learning rate decrease schedule can be painful. Aggressive decays,
such as $\alpha/\sqrt{t}$, or small learning rates, yield very slow convergence
and mediocre performance. On the other hand, gentle decays and high learning
rates yield very unstable training, even divergence sometimes. To overcome these
issues, &lt;strong&gt;adaptive methods&lt;/strong&gt; have been developed around the key idea that &lt;strong&gt;each
weight, that is each coordinate of $x_t$, should be updated using its own
learning rate&lt;/strong&gt;, automatically computed based on the knowledge of past updates.
This way, parameters that are frequently updated take only small steps (to avoid
divergence), while parameters that are rarely updated take rather huge steps
(to speed up convergence). This is summed up in the generic adaptive framework
below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-08-19-adaptive-methods.png&quot; alt=&quot;Adaptive methods&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We call $\alpha_t$ the step size, $\alpha_t/\sqrt{V_t}$ the learning rate,
and restrict ourselves to diagonal variants $V_t = \text{diag}(v_t)$.
This framework essentially allows us to compute a different learning rate for
each weight, by rescaling the step size (common to all weights) with a function
of past gradients (of the loss function with respect to the considered weight,
thus &lt;em&gt;weight-specific&lt;/em&gt;). Using this framework, we can follow the evolution of
adaptive methods over time:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;(&lt;a href=&quot;https://en.wikipedia.org/wiki/Stochastic_gradient_descent&quot;&gt;SGD&lt;/a&gt;) Stochastic gradient descent&lt;/strong&gt;
    &lt;center&gt;$\phi_t(g_1, ..., g_t) = g_t\text{  }$ and
$\text{  }\psi_t(g_1, ..., g_t) = \mathbb{I}$&lt;/center&gt;
    &lt;p&gt;SGD is also an adaptive method, with a specific strategy of not adapting at
all: it forgets everything about the past of each weight, and relies only on
the current gradient to perform the update, with a step size
(and learning rate) $\alpha_t =\alpha/\sqrt{t}$, an aggressive decay.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;(&lt;a href=&quot;http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf&quot;&gt;AdaGrad&lt;/a&gt;) Adaptive gradient descent&lt;/strong&gt;
    &lt;center&gt;$\phi_t(g_1, ..., g_t) = g_t\text{  }$ and
$\text{  }\psi_t(g_1, ..., g_t) = {\text{diag}(\dfrac{1}{t} \sum_{i=1}^t g_i^2)}$&lt;/center&gt;
    &lt;p&gt;With the same step size $\alpha_t = \alpha/\sqrt{t}$, this yields an adaptive
and much more reasonable learning rate of $\alpha/\sqrt{\sum_i g_{ij}}$ for
a the $j$-th weight. When the gradients ${g_{ij}}$ are sparse, i.e.
the $j$-th weight is not frequently updated, this &lt;strong&gt;considerably speeds up
convergence&lt;/strong&gt; (updates are still rare, but much bigger than with SGD).&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;(&lt;a href=&quot;https://www.coursera.org/lecture/neural-networks/rmsprop-divide-the-gradient-by-a-running-average-of-its-recent-magnitude-YQHki&quot;&gt;RMSProp&lt;/a&gt;)&lt;/strong&gt;
    &lt;center&gt;$\phi_t(g_1, ..., g_t) = g_t\text{  }$ and
$\text{  }\psi_t(g_1, ..., g_t) = {\text{diag}((1-\beta)\sum_{i=1}^t \beta^{t-i} g_i^2)}$&lt;/center&gt;
    &lt;p&gt;Despite its huge benefits in some settings, AdaGrad tends to shrink the
learning rates of frequently updated parameters, very quickly to virtually
zero. To overcome this issue, RMSProp restricts the average of past gradients
to a fixed window, instead of the entire past, to avoid shrinking the
learning rates to virtually zero too quickly. In practice, this is
implemented by an &lt;strong&gt;exponentially moving average of past gradients&lt;/strong&gt;.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;(&lt;a href=&quot;https://arxiv.org/pdf/1412.6980.pdf&quot;&gt;Adam&lt;/a&gt;) Adaptive momentum estimation&lt;/strong&gt;
    &lt;center&gt;$\phi_t(g_1, ..., g_t) = (1-\beta_1)\sum_{i=1}^t \beta_1^{t-i} g_i^2{\ }\text{  }$ and
$\text{  }\psi_t(g_1, ..., g_t) = {\text{diag}((1-\beta_2)\sum_{i=1}^t \beta_2^{t-i} g_i^2)}$&lt;/center&gt;
    &lt;p&gt;To further speed up the convergence, Adam adds to RMSProp the idea of
&lt;strong&gt;momentum&lt;/strong&gt; (instead of moving in the direction
of the current gradient only, move in a direction that is a weighted average
of current gradient and previous update, like a rolling ball’s movement is
is influenced by the both the current slope and its momentum; see
&lt;a href=&quot;http://ruder.io/optimizing-gradient-descent/index.html&quot;&gt;Ruder’s post&lt;/a&gt;).
The momentum parameter $\beta_1&amp;gt;0$ considerably
improves the performance of the algorithm, especially in deep learning.
Combining momentum with adaptive methods, Adam is very efficient, and
immensely popular.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;the-non-convergence-of-adam&quot;&gt;The non-convergence of Adam&lt;/h2&gt;

&lt;p&gt;So, what’s wrong with Adam? It turns out that in the convergence proof given
by Kingma &amp;amp; Ba, a flaw resides in the consideration of a specific quantity,
namely:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ \Gamma_{t+1} = \left(\dfrac{\sqrt{V_{t+1}}}{\alpha_{t+1}} -
\dfrac{\sqrt{V_{t}}}{\alpha_{t}}\right)&lt;/script&gt;

&lt;p&gt;Intuitively, $\Gamma_t$ measures the
variations of the inverse of the learning rate. As we saw, convergence requires
a &lt;strong&gt;non-increasing learning rate&lt;/strong&gt; (otherwise the algorithm oscillates too much,
or even diverges), which directly translates to $\Gamma_t \succeq O$ (easy to
see with a diagonal $V_t$). This is the case for both SGD ($v_t$ constant,
$\alpha_t$ decreasing) and AdaGrad ($v_t$ non-decreasing,
$\alpha_t$ decreasing). However, it is no longer the case for Adam (nor RMSProp)
because of the exponentially moving average of past gradients.&lt;/p&gt;

&lt;p&gt;This is actually a huge issue, meaning that in some cases Adam actually
converges to the worst solution possible. Following the example provided by the
authors, consider $C&amp;gt;2$ and $\mathcal{F} = [-1,1]$, and the following losses:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-08-19-ADAM_counterexample2.png&quot; alt=&quot;ADAM counterexample&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The optimal solution would be $x=-1$. However, choosing $\beta_1 = 0$ and
$\beta_2 = {1}/{(1+C^2)}$, Adam actually converges to the worst possible point
$x = +1$. The intuition for this behavior is the following: although the
algorithm observes a large gradient $C$ every $3$ steps,
&lt;strong&gt;it forgets (scales down) this large gradient too quickly (due to the
exponential weights)&lt;/strong&gt; to counterbalance the wrong but most frequent updates.&lt;/p&gt;

&lt;p&gt;So you thought Adam was reliable in all convex (“easy”) cases? Well, no:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Theorem 1.&lt;/strong&gt; There is an online convex optimization problem where Adam has
non-zero average regret.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Wait, but this is for a specific choice of parameters. We allowed the choice of
a very small $\beta_2$, and to quote the paper, “this example also provides
intuition for why large $\beta_2$ is advisable […], and indeed in practice
using large $\beta_2$ helps”. So maybe we are safe when using correctly chosen
parameters? Well, no:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Theorem 2.&lt;/strong&gt; For any constant $\beta_1,\beta_2 \in [0,1)$ such that $\beta_1
&amp;lt; \sqrt{\beta_2}$ [typically satisfied by default settings], there is an online
convex optimization problem where Adam has non-zero average regret.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;All right, but this was in online optimization, where one could carefully design
a sequence of loss functions to specifically fool Adam. We should be fine with
stochastic optimization where such a design is impossible, right? Well, no:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Theorem 3.&lt;/strong&gt; For any constant $\beta_1,\beta_2 \in [0,1)$ such that $\beta_1
&amp;lt; \sqrt{\beta_2}$ [typically satisfied by default settings], there is
a stochastic convex optimization problem for which Adam does not converge to the
optimal solution.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now this is actually a major concern, since stochastic convex optimization is
actually one of the simplest problems that we expect Adam to be able to solve
(and deep learning consists mostly of non-convex stochastic optimization,
which is reputed much harder). In practice, “fixing Adam” in cases of bad
convergence behavior would typically require using different hyper-parameters
for each dimension which, well, makes you wonder why you’re using adaptive
methods in the first place (especially given the very high number of dimensions
in typical deep learning applications).&lt;/p&gt;

&lt;p&gt;Another important note is that this analysis remains valid for &lt;strong&gt;any adaptive
method that is based on exponentially weighted moving averages (EWMA) of the
gradients&lt;/strong&gt;, including RMSProp, AdaDelta and NAdam, which are therefore also
flawed.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;amsgrad-a-new-and-fixed-variant&quot;&gt;AMSGrad, a new (and fixed) variant&lt;/h2&gt;

&lt;p&gt;Now that the maths have spoken and revealed the problem with Adam,
what can be done? EWMA-based algorithms
have actually brought a lot in terms of performance improvement and robustness
to hyper-parameters choice, and it would be quite a pity to simply throw it all
away for just a hole discovered in the proof.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-08-19-AMSGRAD.png&quot; alt=&quot;AMSGrad&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To overcome this issue, the authors propose a new variant, AMSGrad, described
in the algorithm above, that we explain in the next few lines.
Remember that the issue with Adam resides in $\Gamma_t$, which should be
semi-definite positive, while in some cases it is not because
$\frac{v_{t+1, j}}{\alpha_{t+1}} - \frac{v_{t, j}}{\alpha_{t}} &amp;lt; 0$ for some
index $j$. Well, a quick hotfix would be to replace $v_{t+1}$ by $\max(v_t,
v_{t+1})$, which would ensure $\Gamma_t \succeq 0$. But this would bias our
computations of the EWMA…
However we can decouple the two processes by keeping
two running variables: one “true” running variable $v_{t+1}$ used to accurately
compute the EWMA (correctly accounting for the past), and one “used-in-updates”
running variable ${\hat v_{t+1}} = {\max(v_{t+1}, \hat v_t)}$ used to ensure
a non-increasing learning rate (hence the correctness of the algorithm).&lt;/p&gt;

&lt;p&gt;Theoretical justifications of AMSGrad back up this claim: for reasonable choices
of parameters, the regret is bounded in $O(\sqrt{T})$. Additionally, for a
specific choice of momentum decay $\beta_{1t} = \beta_1 \lambda^{t-1}$, the
authors prove a bound on the regret that can hugely benefit from sparse
gradients, potentially “considerably better than $O(\sqrt{dT})$ regret of SGD”.&lt;/p&gt;

&lt;p&gt;Does this translate into good empirical performance? The paper provides the
convergence curves for a synthetic example that is close to the previous
example (with $\mathcal{F} = [-1, 1]$, the optimal solution being $x=-1$):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-08-19-synthetic_example.png&quot; alt=&quot;Synthetic example&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-08-19-convergence_curves.png&quot; alt=&quot;Convergence curves&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;This example shows that AMSGrad works on the synthetic example where Adam fails
to converge to the true solution, which is always a good sign, since it was why
it was designed in the first place. But what about standard convergence
benchmarks on more interesting problems, like logistic regression or neural
networks? Reddi et al. provide graphics that claim for AMSGrad
equal or better performance compared to Adam for logistic regression,
feed-forward neural net (1 hidden layer) on MNIST, and CIFARNET. However, in an
independent
&lt;a href=&quot;https://fdlm.github.io/post/amsgrad/&quot;&gt;implementation by Filip Korzeniowski&lt;/a&gt;
tested in various settings (you should definitely check his post for extensive
details and comparisons), the experiments do not support any claim of
practical difference between Adam and AMSGrad. We show below the validation
accuracy (what we care about in the end) he gets for both algorithm on CIFAR-10.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-08-19-comparison.png&quot; alt=&quot;Comparison&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;center&gt;Validation accuracy on CIFAR-10 (VGG-16).
&lt;br /&gt;Adam in blue, AMSGrad in red.
&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;does-it-matter&quot;&gt;Does it matter?&lt;/h2&gt;

&lt;p&gt;In my opinion, it is pretty clear that the main interest of the paper lies
in pointing out the flaw in Adam’s proof, and how it affects the convergence
behavior in some cases. AMSGrad sounded somewhat more like a hotfix than a real
replacement, providing a sounder algorithm while maintaining Adam’s good
performance. AMSGrad will not change the course of stochastic optimization’s
(nor deep learning’s) history, may it even come to someday replace Adam
in practice. &lt;em&gt;In the end, it doesn’t even matter (that much)&lt;/em&gt; ; a true
“breakthrough” replacement is yet to come.&lt;/p&gt;

&lt;p&gt;What is more interesting is the meta-aspect of the proof-checking side of this
paper. It seems very important to me that empirical observations of bad
convergence behavior are finally backed up by theoretical justifications, in
other words, that &lt;strong&gt;someone finally checked the maths&lt;/strong&gt;. I find it actually
surprising that despite its “reasonable” length of 4 pages, no one checked the
proof and spotted this mistake, while in the meantime Adam got increasingly
popular and widely used. Note that I barely ever read the proofs myself. I would
tend to link this phenomenon to a deeper trend in the machine/deep learning
community: people (and scientists are people too) get really excited about the
results, the performance and the new opportunities brought by an exponentially
growing field, and we just forget how to do good science along the way. The
reproducibility crisis denounced by researchers like Joëlle Pineau
(especially in reinforcement learning) is one example; the fact that everyone
skips the proofs to go straight to the next exciting paper is another.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content><author><name>Romain Girard</name></author><category term="ICLR 2018" /><category term="Adam" /><category term="Optimization" /><category term="Deep Learning" /><category term="Neural Networks" /><category term="ICLR" /><summary type="html"></summary></entry></feed>